## [Реализация алгоритма](./BinarySearch.java)

## Пояснение к алгоритму:

### Почему бинарный поиск нельзя применять к неотсортированному массиву?
**Ответ:** Бинарный поиск основан на свойстве отсортированного массива - при сравнении с средним элементом мы можем гарантированно определить, в какой половине массива находится искомый элемент. В неотсортированном массиве это свойство не выполняется, поэтому алгоритм может пропустить целевой элемент или дать неверный результат.

### Асимптотическая сложность по времени: O(log n)
**Объяснение:** На каждой итерации цикла мы уменьшаем область поиска вдвое. Для массива размером n:
- После 1 итерации: останется n/2 элементов
- После 2 итераций: n/4 элементов
- После k итераций: n/2^k элементов

Процесс продолжается, пока n/2^k ≥ 1, то есть k ≤ log₂n. Таким образом, максимальное количество итераций пропорционально log₂n.

### Сложность по памяти: O(1)
**Объяснение:** Алгоритм использует только фиксированное количество дополнительных переменных (left, right, mid), которые не зависят от размера входного массива. Память используется константно, независимо от размера входных данных.

### Принцип работы алгоритма:
1. **Инициализация:** Устанавливаем границы поиска на весь массив
2. **Цикл:** Пока левая граница не превысит правую
3. **Середина:** Вычисляем средний индекс (без переполнения)
4. **Сравнение:**
    - Если нашли target - возвращаем индекс
    - Если target больше - ищем в правой половине
    - Если target меньше - ищем в левой половине
5. **Завершение:** Если элемент не найден - возвращаем -1